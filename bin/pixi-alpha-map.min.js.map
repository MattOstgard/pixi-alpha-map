{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","pixi-alpha-map.min.js","src/AlphaMapMovieClip.js","src/AlphaMapShader.js","src/AlphaMapSprite.js","src/AlphaMapVideoShader.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","alphaMap","AlphaMapShader","AlphaMapVideoShader","AlphaMapSprite","AlphaMapMovieClip","shaderTexPairs","videoShader","PIXI","this","self","window","./AlphaMapMovieClip.js","./AlphaMapShader.js","./AlphaMapSprite.js","./AlphaMapVideoShader.js",2,"textures","alphaTextures","extras","MovieClip","shaders","alphaTexture","shader","push","prototype","Object","create","constructor","_renderWebGL","renderer","currentFrame","setObjectRenderer","plugins","sprite","render",3,"AbstractFilter","join","type","value","defineProperties","get","uniforms","set",4,"texture","Sprite",5,"shaderManager"],"mappings":"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","file":"pixi-alpha-map.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global){\n/**\n * @namespace PIXI.alphaMap\n */\n\nvar alphaMap = {\n    AlphaMapShader: require('./AlphaMapShader.js'),\n    AlphaMapVideoShader: require('./AlphaMapVideoShader.js'),\n    AlphaMapSprite: require('./AlphaMapSprite.js'),\n    AlphaMapMovieClip: require('./AlphaMapMovieClip.js')\n}\n\n// Due to a bug in Pixi v3 we have to do mulitple shader instances.\n// Instead of using just one shader, we have to use multiple whenever there is an alpha map texture that is different. \nalphaMap.shaderTexPairs = [];\n\n// \nalphaMap.videoShader = new alphaMap.AlphaMapVideoShader();\n\nmodule.exports = global.PIXI.alphaMap = alphaMap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLmFscGhhTWFwXG4gKi9cblxudmFyIGFscGhhTWFwID0ge1xuICAgIEFscGhhTWFwU2hhZGVyOiByZXF1aXJlKCcuL0FscGhhTWFwU2hhZGVyLmpzJyksXG4gICAgQWxwaGFNYXBWaWRlb1NoYWRlcjogcmVxdWlyZSgnLi9BbHBoYU1hcFZpZGVvU2hhZGVyLmpzJyksXG4gICAgQWxwaGFNYXBTcHJpdGU6IHJlcXVpcmUoJy4vQWxwaGFNYXBTcHJpdGUuanMnKSxcbiAgICBBbHBoYU1hcE1vdmllQ2xpcDogcmVxdWlyZSgnLi9BbHBoYU1hcE1vdmllQ2xpcC5qcycpXG59XG5cbi8vIER1ZSB0byBhIGJ1ZyBpbiBQaXhpIHYzIHdlIGhhdmUgdG8gZG8gbXVsaXRwbGUgc2hhZGVyIGluc3RhbmNlcy5cbi8vIEluc3RlYWQgb2YgdXNpbmcganVzdCBvbmUgc2hhZGVyLCB3ZSBoYXZlIHRvIHVzZSBtdWx0aXBsZSB3aGVuZXZlciB0aGVyZSBpcyBhbiBhbHBoYSBtYXAgdGV4dHVyZSB0aGF0IGlzIGRpZmZlcmVudC4gXG5hbHBoYU1hcC5zaGFkZXJUZXhQYWlycyA9IFtdO1xuXG4vLyBcbmFscGhhTWFwLnZpZGVvU2hhZGVyID0gbmV3IGFscGhhTWFwLkFscGhhTWFwVmlkZW9TaGFkZXIoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUElYSS5hbHBoYU1hcCA9IGFscGhhTWFwOyJdfQ==","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n/**\n * @namespace PIXI.alphaMap\n */\n\nvar alphaMap = {\n    AlphaMapShader: require('./AlphaMapShader.js'),\n    AlphaMapVideoShader: require('./AlphaMapVideoShader.js'),\n    AlphaMapSprite: require('./AlphaMapSprite.js'),\n    AlphaMapMovieClip: require('./AlphaMapMovieClip.js')\n}\n\n// Due to a bug in Pixi v3 we have to do mulitple shader instances.\n// Instead of using just one shader, we have to use multiple whenever there is an alpha map texture that is different. \nalphaMap.shaderTexPairs = [];\n\n// \nalphaMap.videoShader = new alphaMap.AlphaMapVideoShader();\n\nmodule.exports = global.PIXI.alphaMap = alphaMap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./AlphaMapMovieClip.js\":2,\"./AlphaMapShader.js\":3,\"./AlphaMapSprite.js\":4,\"./AlphaMapVideoShader.js\":5}],2:[function(require,module,exports){\n/**\n * An AlphaMapMovieClip allows the use of two separate images for color and transparency.\n * In most cases this is useful when you want to are using an image format like jpg that does not support transparency.\n *\n * ```js\n * //TODO\n * ```\n *\n * @class\n * @extends PIXI.extras.MovieClip\n * @memberof PIXI.alphaMap\n * @param textures {PIXI.Texture[]} the RGB (color) textures.\n * @param alphaTexture {PIXI.Texture} the Alpha (transparency) textures that correspond to each texture the textures array.\n */\nfunction AlphaMapMovieClip(textures, alphaTextures)\n{\n    PIXI.extras.MovieClip.call(this, textures);\n\n    // Create reusable instance of the shader\n    var shaders = [];\n    for (var i in alphaTextures) {\n        var alphaTexture = alphaTextures[i];\n        var shader = null;\n        for (var i in PIXI.alphaMap.shaderTexPairs) {\n            if (PIXI.alphaMap.shaderTexPairs[i].alphaTexture === alphaTexture) {\n                shader = PIXI.alphaMap.shaderTexPairs[i].shader;\n            }\n        }\n\n        //\n        if (shader === null) {\n            shader = new PIXI.alphaMap.AlphaMapShader();\n            PIXI.alphaMap.shaderTexPairs.push({shader: shader, alphaTexture: alphaTexture});\n        }\n\n        //\n        shaders.push(shader);\n    }\n\n    /**\n     * The shader that will be used to render the sprite. By default this is set to AlphaMapShader.\n     *\n     * @member {PIXI.AbstractFilter|PIXI.Shader}\n     */\n    this.shaders = shaders;\n\n    /**\n     * the Alpha (transparency) textures that correspond to each texture the textures array.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.AlphaMapMovieClip#\n     */\n    this.alphaTextures = alphaTextures;\n}\n\n// Constructor\nAlphaMapMovieClip.prototype = Object.create(PIXI.extras.MovieClip.prototype);\nAlphaMapMovieClip.prototype.constructor = AlphaMapMovieClip;\nmodule.exports = AlphaMapMovieClip;\n\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {PIXI.WebGLRenderer}\n* @private\n*/\nAlphaMapMovieClip.prototype._renderWebGL = function (renderer)\n{\n    this.shader = this.shaders[this.currentFrame];\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    this.shader.alphaTexture = this.alphaTextures[this.currentFrame];\n    renderer.plugins.sprite.render(this);\n};\n},{}],3:[function(require,module,exports){\nfunction AlphaMapShader()\n{\n    PIXI.AbstractFilter.call(this,\n        // Vertex shader\n        null,\n\n        // Fragment shader\n        [\n            'precision lowp float;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec4 vColor;',\n\n            'uniform sampler2D uSampler;',\n            'uniform sampler2D alphaTexture;',\n\n            'void main(void){',\n            '   vec3 color = texture2D(uSampler, vTextureCoord).rgb;',\n            '   float alpha = texture2D(alphaTexture, vTextureCoord).r;',\n            '   gl_FragColor = vec4(color.r, color.g, color.b, alpha) * vColor;',\n            '}'\n        ].join('\\n'),\n\n        // Custom uniforms\n        {\n            alphaTexture: { type: 'sampler2D', value: 0 }\n        }\n    );\n}\n\nAlphaMapShader.prototype = Object.create(PIXI.AbstractFilter.prototype);\nAlphaMapShader.prototype.constructor = AlphaMapShader;\nmodule.exports = AlphaMapShader;\n\nObject.defineProperties(AlphaMapShader.prototype, {\n    /**\n     * Alpha texture to be used as transparency.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.alphaMap.AlphaMapShader#\n     */\n    alphaTexture: {\n        get: function ()\n        {\n            return this.uniforms.alphaTexture.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.alphaTexture.value = value;\n        }\n    }\n});\n},{}],4:[function(require,module,exports){\n/**\n * An AlphaMapSprite allows the use of two separate images for color and transparency.\n * In most cases this is useful when you want to are using an image format like jpg that does not support transparency.\n *\n * ```js\n * //TODO\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.alphaMap\n * @param texture {PIXI.Texture} the RGB (color) texture.\n * @param alphaTexture {PIXI.Texture} the Alpha (transparency) texture.\n */\nfunction AlphaMapSprite(texture, alphaTexture)\n{\n    PIXI.Sprite.call(this, texture);\n\n    // Create reusable instance of the shader\n    var shader = null;\n    for (var i in PIXI.alphaMap.shaderTexPairs) {\n        if (PIXI.alphaMap.shaderTexPairs[i].alphaTexture === alphaTexture) {\n            shader = PIXI.alphaMap.shaderTexPairs[i].shader;\n        }\n    }\n\n    //\n    if (shader === null) {\n        shader = new PIXI.alphaMap.AlphaMapShader();\n        PIXI.alphaMap.shaderTexPairs.push({shader: shader, alphaTexture: alphaTexture});\n    }\n\n    /**\n     * The shader that will be used to render the sprite. By default this is set to AlphaMapShader.\n     *\n     * @member {PIXI.AbstractFilter|PIXI.Shader}\n     */\n    this.shader = shader;\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.AlphaMapSprite#\n     */\n    this.alphaTexture = alphaTexture;\n}\n\n// Constructor\nAlphaMapSprite.prototype = Object.create(PIXI.Sprite.prototype);\nAlphaMapSprite.prototype.constructor = AlphaMapSprite;\nmodule.exports = AlphaMapSprite;\n\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {PIXI.WebGLRenderer}\n* @private\n*/\nAlphaMapSprite.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    this.shader.alphaTexture = this.alphaTexture;\n    renderer.plugins.sprite.render(this);\n};\n},{}],5:[function(require,module,exports){\nfunction AlphaMapVideoShader(shaderManager)\n{\n    PIXI.AbstractFilter.call(this,\n        // Vertex shader\n        [\n            'precision lowp float;',\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n            'attribute vec4 aColor;',\n\n            'uniform mat3 projectionMatrix;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vTextureCoord2;',\n            'varying vec4 vColor;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vTextureCoord = vec2(aTextureCoord.x, aTextureCoord.y * 0.5);',\n            '   vTextureCoord2 = vec2(aTextureCoord.x, (aTextureCoord.y * 0.5) + 0.5);',\n            '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n            '}'\n        ].join('\\n'),\n\n        // Fragment shader\n        [\n            'precision lowp float;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vTextureCoord2;',\n            'varying vec4 vColor;',\n\n            'uniform sampler2D uSampler;',\n\n            'void main(void){',\n\n            '   float alpha = texture2D(uSampler, vTextureCoord).g;',\n            '   vec3 color = texture2D(uSampler, vTextureCoord2).rgb;',\n                // Remap values so that 0.064 is black because on PC nvidia limits the colors to 16-235 for some stupid\n                // reason. To do this right we would have to load a test video, check the black value the video is\n                // outputting and pick an appropriate shader.\n            '    vec4 nvidiaCrushColors = (vec4(color.rgb, alpha) - 0.063) * 1.06723;',\n            '   gl_FragColor = nvidiaCrushColors * vColor;',\n            '}'\n        ].join('\\n'),\n\n        // Custom uniforms\n        null\n    );\n}\n\n// Constructor\nAlphaMapVideoShader.prototype = Object.create(PIXI.AbstractFilter.prototype);\nAlphaMapVideoShader.prototype.constructor = AlphaMapVideoShader;\nmodule.exports = AlphaMapVideoShader;\n},{}]},{},[1])\n\n","/**\n * An AlphaMapMovieClip allows the use of two separate images for color and transparency.\n * In most cases this is useful when you want to are using an image format like jpg that does not support transparency.\n *\n * ```js\n * //TODO\n * ```\n *\n * @class\n * @extends PIXI.extras.MovieClip\n * @memberof PIXI.alphaMap\n * @param textures {PIXI.Texture[]} the RGB (color) textures.\n * @param alphaTexture {PIXI.Texture} the Alpha (transparency) textures that correspond to each texture the textures array.\n */\nfunction AlphaMapMovieClip(textures, alphaTextures)\n{\n    PIXI.extras.MovieClip.call(this, textures);\n\n    // Create reusable instance of the shader\n    var shaders = [];\n    for (var i in alphaTextures) {\n        var alphaTexture = alphaTextures[i];\n        var shader = null;\n        for (var i in PIXI.alphaMap.shaderTexPairs) {\n            if (PIXI.alphaMap.shaderTexPairs[i].alphaTexture === alphaTexture) {\n                shader = PIXI.alphaMap.shaderTexPairs[i].shader;\n            }\n        }\n\n        //\n        if (shader === null) {\n            shader = new PIXI.alphaMap.AlphaMapShader();\n            PIXI.alphaMap.shaderTexPairs.push({shader: shader, alphaTexture: alphaTexture});\n        }\n\n        //\n        shaders.push(shader);\n    }\n\n    /**\n     * The shader that will be used to render the sprite. By default this is set to AlphaMapShader.\n     *\n     * @member {PIXI.AbstractFilter|PIXI.Shader}\n     */\n    this.shaders = shaders;\n\n    /**\n     * the Alpha (transparency) textures that correspond to each texture the textures array.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.AlphaMapMovieClip#\n     */\n    this.alphaTextures = alphaTextures;\n}\n\n// Constructor\nAlphaMapMovieClip.prototype = Object.create(PIXI.extras.MovieClip.prototype);\nAlphaMapMovieClip.prototype.constructor = AlphaMapMovieClip;\nmodule.exports = AlphaMapMovieClip;\n\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {PIXI.WebGLRenderer}\n* @private\n*/\nAlphaMapMovieClip.prototype._renderWebGL = function (renderer)\n{\n    this.shader = this.shaders[this.currentFrame];\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    this.shader.alphaTexture = this.alphaTextures[this.currentFrame];\n    renderer.plugins.sprite.render(this);\n};","function AlphaMapShader()\n{\n    PIXI.AbstractFilter.call(this,\n        // Vertex shader\n        null,\n\n        // Fragment shader\n        [\n            'precision lowp float;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec4 vColor;',\n\n            'uniform sampler2D uSampler;',\n            'uniform sampler2D alphaTexture;',\n\n            'void main(void){',\n            '   vec3 color = texture2D(uSampler, vTextureCoord).rgb;',\n            '   float alpha = texture2D(alphaTexture, vTextureCoord).r;',\n            '   gl_FragColor = vec4(color.r, color.g, color.b, alpha) * vColor;',\n            '}'\n        ].join('\\n'),\n\n        // Custom uniforms\n        {\n            alphaTexture: { type: 'sampler2D', value: 0 }\n        }\n    );\n}\n\nAlphaMapShader.prototype = Object.create(PIXI.AbstractFilter.prototype);\nAlphaMapShader.prototype.constructor = AlphaMapShader;\nmodule.exports = AlphaMapShader;\n\nObject.defineProperties(AlphaMapShader.prototype, {\n    /**\n     * Alpha texture to be used as transparency.\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.alphaMap.AlphaMapShader#\n     */\n    alphaTexture: {\n        get: function ()\n        {\n            return this.uniforms.alphaTexture.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.alphaTexture.value = value;\n        }\n    }\n});","/**\n * An AlphaMapSprite allows the use of two separate images for color and transparency.\n * In most cases this is useful when you want to are using an image format like jpg that does not support transparency.\n *\n * ```js\n * //TODO\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.alphaMap\n * @param texture {PIXI.Texture} the RGB (color) texture.\n * @param alphaTexture {PIXI.Texture} the Alpha (transparency) texture.\n */\nfunction AlphaMapSprite(texture, alphaTexture)\n{\n    PIXI.Sprite.call(this, texture);\n\n    // Create reusable instance of the shader\n    var shader = null;\n    for (var i in PIXI.alphaMap.shaderTexPairs) {\n        if (PIXI.alphaMap.shaderTexPairs[i].alphaTexture === alphaTexture) {\n            shader = PIXI.alphaMap.shaderTexPairs[i].shader;\n        }\n    }\n\n    //\n    if (shader === null) {\n        shader = new PIXI.alphaMap.AlphaMapShader();\n        PIXI.alphaMap.shaderTexPairs.push({shader: shader, alphaTexture: alphaTexture});\n    }\n\n    /**\n     * The shader that will be used to render the sprite. By default this is set to AlphaMapShader.\n     *\n     * @member {PIXI.AbstractFilter|PIXI.Shader}\n     */\n    this.shader = shader;\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.AlphaMapSprite#\n     */\n    this.alphaTexture = alphaTexture;\n}\n\n// Constructor\nAlphaMapSprite.prototype = Object.create(PIXI.Sprite.prototype);\nAlphaMapSprite.prototype.constructor = AlphaMapSprite;\nmodule.exports = AlphaMapSprite;\n\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {PIXI.WebGLRenderer}\n* @private\n*/\nAlphaMapSprite.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    this.shader.alphaTexture = this.alphaTexture;\n    renderer.plugins.sprite.render(this);\n};","function AlphaMapVideoShader(shaderManager)\n{\n    PIXI.AbstractFilter.call(this,\n        // Vertex shader\n        [\n            'precision lowp float;',\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n            'attribute vec4 aColor;',\n\n            'uniform mat3 projectionMatrix;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vTextureCoord2;',\n            'varying vec4 vColor;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vTextureCoord = vec2(aTextureCoord.x, aTextureCoord.y * 0.5);',\n            '   vTextureCoord2 = vec2(aTextureCoord.x, (aTextureCoord.y * 0.5) + 0.5);',\n            '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n            '}'\n        ].join('\\n'),\n\n        // Fragment shader\n        [\n            'precision lowp float;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vTextureCoord2;',\n            'varying vec4 vColor;',\n\n            'uniform sampler2D uSampler;',\n\n            'void main(void){',\n\n            '   float alpha = texture2D(uSampler, vTextureCoord).g;',\n            '   vec3 color = texture2D(uSampler, vTextureCoord2).rgb;',\n                // Remap values so that 0.064 is black because on PC nvidia limits the colors to 16-235 for some stupid\n                // reason. To do this right we would have to load a test video, check the black value the video is\n                // outputting and pick an appropriate shader.\n            '    vec4 nvidiaCrushColors = (vec4(color.rgb, alpha) - 0.063) * 1.06723;',\n            '   gl_FragColor = nvidiaCrushColors * vColor;',\n            '}'\n        ].join('\\n'),\n\n        // Custom uniforms\n        null\n    );\n}\n\n// Constructor\nAlphaMapVideoShader.prototype = Object.create(PIXI.AbstractFilter.prototype);\nAlphaMapVideoShader.prototype.constructor = AlphaMapVideoShader;\nmodule.exports = AlphaMapVideoShader;"],"sourceRoot":"./"}